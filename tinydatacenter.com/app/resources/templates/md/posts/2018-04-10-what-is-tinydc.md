{:title "What is TinyDC?"
 :layout :post}

TinyDC is a way to plant a seed that grows into a massive tree. It's built on timeless
wisdom in the art of software construction. It's no fluff, just descriptions of what's
done.

It might work with old systems, but it's for new systems. It might be recognizable with
expert eyes, but it's for beginner eyes. "In the beginners mind there are many possiblities,
in the expert's mind there are few." (Shunryu Suzuki).

RasPis are readily available, powerful, cheap, and consistent. Using SD card images
one can maintain many workstations powered by a single RasPi by swapping cards, 
or create a fail-safe procedure by having extra hardware on hand and stored with 
the operations manual.

Concretely it's a repo that you clone onto a new Single Board Computer to start
a project. It's a set of guides and videos that help a person with no computing 
experience get the most of their hardware.

Following [the principles of TinyDC](/principles.html) and using a creative mindset, anyone can realize
their dream project. Even if you don't know what your project is when you start 
it, TinyDC is inspiration to take the first step and assistance in taking the 
1000ths step of your IT journey.



-

## History

In December of 2017 there existed a pile of RasPis and an author's sabbatical
in which he spent a month watching videos and reading articles to get an idea
of what the next step in his career will be. In November he'd left his 
job and bought around $500 of A/V equipment to document the process of whatever 
his next endeavor would be, considering funding sources like Patreon and 
Indiegogo.

TinyDC began with the realization that Raspberry Pis are powerful enough to 
run web applications, about equivalent in power to a small AWS or GCP container.
They also run Docker, which is the preferred way for developers, engineers, and 
ops people to interface together.

Humble author, having been involved in large
budget and multi-region/global infrastructure projects crunching massive amounts 
of data, is painfully aware of the runtime characteristics of systems from high 
level languages Java and Javascript down through POSIX, virtual memory, assembly,
and into physics and mathematics. This knowledge is a stack that can take 
many lifetimes to understand, but science gives us a framework to interface and 
progress systematically forward.


 